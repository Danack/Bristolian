<?php

namespace Bristolian\CliController;

use Bristolian\Config\Config;
use Bristolian\Exception\BristolianException;
use Bristolian\Model\Chat\UserChatMessage;
use PDO;

function generate_table_strings($sorted_column_names)
{
    $separator = "";
    $columns_separated_by_comma_new_line = "";
    $values_names_separated_by_comma_new_line = "";

    foreach ($sorted_column_names as $column_name) {
//        if (strcasecmp($column_name, 'created_at') === 0) {
//            continue;
//        }
//        if (strcasecmp($column_name, 'updated_at') === 0) {
//            continue;
//        }

        $columns_separated_by_comma_new_line .= $separator . "    " . $column_name;
        $values_names_separated_by_comma_new_line .= $separator . "    :" . $column_name;
        $separator = ",\n";
    }

    $columns_separated_by_comma_new_line .= "\n";
    $values_names_separated_by_comma_new_line .= "\n";

    return [$columns_separated_by_comma_new_line, $values_names_separated_by_comma_new_line];
}


function generate_table_update_strings($sorted_column_names)
{
    $separator = "";
    $update_strings = "";

    foreach ($sorted_column_names as $column_name) {
        $update_strings .= $separator . "  $column_name = :" . $column_name ."";
        $separator = ",\n";
    }

    return $update_strings;
}







/**
 *
 * @codeCoverageIgnore
 * @param string $tableName
 * @param array $columns_info
 * @return void
 * @throws \Safe\Exceptions\FilesystemException
 */
function generate_table_helper_class(string $tableName, array $columns_info): void
{
    $output_filename = __DIR__ . "/../../Bristolian/Database/" . $tableName . ".php";

    $contents = "<?php\n\n";
    $contents .= "// Auto-generated file do not edit\n\n";
    $contents .= "// generated with 'php cli.php generate:php_table_helper_classes'\n\n";
    $contents .= "namespace Bristolian\\Database;\n\n";

    $columns_separated_by_comma_new_line = "";
    $values_names_separated_by_comma_new_line = "";


    $column_names_select = [];
    $column_names_insert = [];
    $column_names_update = [];
    foreach ($columns_info as $column) {
        $column_names_select[] = $column['COLUMN_NAME'];
        if (str_contains($column['EXTRA'], 'auto_increment') === true) {
            // auto-increment columns are autogenerated, not provided on insert.
            continue;
        }
        if (strcasecmp($column['COLUMN_NAME'], 'created_at') === 0) {
            continue;
        }
        if (strcasecmp($column['COLUMN_NAME'], 'updated_at') === 0) {
            continue;
        }
        if (strcasecmp($column['COLUMN_NAME'], 'start_time') === 0) {
            continue;
        }



        $column_names_insert[] = $column['COLUMN_NAME'];

        if (str_ends_with($column['COLUMN_NAME'], 'id')) {
            continue;
        }

        $column_names_update[] = $column['COLUMN_NAME'];
    }

    // Insert
    $sorted_column_names_insert = customSort($column_names_insert);
    [$columns_separated_by_comma_new_line, $values_names_separated_by_comma_new_line]
        = generate_table_strings($sorted_column_names_insert);

    $contents .= "class $tableName\n";
    $contents .= "{\n";
    $contents .= "    const INSERT = <<< SQL\n";
    $contents .= "insert into $tableName (\n";
    $contents .= $columns_separated_by_comma_new_line;
    $contents .= ")\n";
    $contents .= "values (\n";
    $contents .= $values_names_separated_by_comma_new_line;
    $contents .= ")\n";
    $contents .= "SQL;\n\n";

    // Select
    $sorted_column_names_select = customSort($column_names_select);
    [$columns_separated_by_comma_new_line, $values_names_separated_by_comma_new_line]
        = generate_table_strings($sorted_column_names_select);

    $contents .= "    const SELECT = <<< SQL\n";
    $contents .= "select\n";
    $contents .= $columns_separated_by_comma_new_line;
    $contents .= "from\n  $tableName \n"; // trailing space to avoid errors
    $contents .= "SQL;\n\n";

    // Update
    $sorted_column_names_update = customSort($column_names_update);
    $update_string = generate_table_update_strings($sorted_column_names_update);
    $contents .= "    const UPDATE = <<< SQL\n";
    $contents .= "update\n";
    $contents .= "  $tableName\n";
    $contents .= "set\n";
    $contents .= $update_string . "\n";
    $contents .= "where\n";
    $contents .= "  id = :id\n";
    $contents .= "  limit 1\n"; // useless?
    $contents .= "SQL;\n\n";
    $contents .= "}\n";



    \Safe\file_put_contents($output_filename, $contents);
}

function getTypeDocDescription(\ReflectionClass $rc)
{
    $description = '';

    $doc = $rc->getDocComment();

    // TODO - extract this to a tested function.
    if ($doc === false) {
        return 'no description available';
    }

    // Remove /** */ and leading * characters
    $clean = preg_replace('/^\s*\/\*\*|\*\/\s*$/', '', $doc);
    $clean = preg_replace('/^\s*\*\s?/m', '', $clean);

    // If there's an @description tag, use that
    if (preg_match('/@description\s+(.*)/i', $clean, $m)) {
        $description = trim($m[1]);
    } else {
        // Otherwise take the first non-empty line as a summary
        foreach (explode("\n", $clean) as $line) {
            $line = trim($line);
            if ($line !== '' && str_starts_with($line, '@') === false) {
                $description = $line;
                break;
            }
        }
    }

    return $description;
}

/**
 * Function to generate TypeScript definition of an interface for a PHP
 * class, so that data transferred from PHP to the front-end can be typed.
 *
 * Code is not unit tested as just not worth it currently.
 *
 * @codeCoverageIgnore
 * @param class-string $type
 * @return array{string, string[]} Returns the interface content and array of date field names
 */
function generateInterfaceForClass(string $type): array
{

    // TODO - this is a hack. It would almost certainly be better to
    // use https://www.npmjs.com/package/openapi-typescript but as our
    // Open API spec isn't generating, this will work for the time being.

    $content = '';
    $dateFields = [];

    $rc = new \ReflectionClass($type);

    $content .= "// " . getTypeDocDescription($rc) . "\n";;
    $content .= "// Source type is $type\n";

    $name = $rc->getShortName();
    $content .= "export interface $name {\n";

    foreach ($rc->getProperties() as $property) {
        $nullable = false;

        $php_type = $property->getType();
        $php_type = (string)$php_type;

        if (str_starts_with($php_type, "?") === true) {
            $php_type = ltrim($php_type, '?');
            $nullable = true;
        }

        if (strcasecmp($php_type, 'DateTimeImmutable') === 0 ||
            strcasecmp($php_type, 'DateTimeInterface') === 0 ||
            strcasecmp($php_type, 'DateTime') === 0) {
            $php_type = "Date";
            $dateFields[] = $property->getName();
        }

        if (strcasecmp($php_type, 'int') === 0) {
            $php_type = "number";
        }

        if ($nullable === true) {
            $php_type .= "|null";
        }

        $content .= "    " . $property->getName() . ": " . $php_type . ";\n";
    }

    $content .= "}\n";

    return [$content, $dateFields];
}

/**
 * Generate a TypeScript conversion function for a type that converts
 * string date fields to Date objects.
 *
 * @codeCoverageIgnore
 * @param class-string $type
 * @param string[] $dateFields
 * @return string
 */
function generateConversionFunctionForClass(string $type, array $dateFields): string
{
    if (count($dateFields) === 0) {
        return '';
    }

    $rc = new \ReflectionClass($type);
    $name = $rc->getShortName();

    $content = "// Conversion function for $type\n";
    $content .= "export function create$name(data: DateToString<$name>): $name {\n";
    $content .= "  return convertDatesFromStrings<$name>(\n";
    $content .= "    data,\n";
    $content .= "    [";
    
    $separator = "";
    foreach ($dateFields as $field) {
        $content .= $separator . "'$field'";
        $separator = ", ";
    }
    
    $content .= "]\n";
    $content .= "  );\n";
    $content .= "}\n";

    return $content;
}

/**
 * Function to generate TypeScript definition of an enum from a PHP
 * Backed Enum class, so that data transferred from PHP to the front-end can be typed.
 *
 * Code is not unit tested as just not worth it currently.
 *
 * @codeCoverageIgnore
 * @param class-string $type
 * @return string
 */
function generateEnumForClass(string $type): string
{
    $content = '';

    $rc = new \ReflectionClass($type);

    $cases = getEnumCases($type);

    $name = $rc->getShortName();


    $content .= "// " . getTypeDocDescription($rc) . "\n";
    $content .= "// Source PHP type: $type\n";

    $content .= "export enum $name {\n";

    // Iterate over all cases and print name and value
    foreach ($cases as $case) {
        if (is_string($case->value) === true) {
            $content .= sprintf(
                "  %s = \"%s\",\n",
                $case->name,
                $case->value
            );
        }
        else if (is_int($case->value) === true) {
            $content .= sprintf(
                "  %s = %s,\n",
                $case->name,
                $case->value
            );
        }
        else {
            throw new \Exception("Unsupported type (neither string nor int) '" . var_export($case, true) . "'.");
        }
    }


    $content .= "}\n";





    return $content;
}









/**
 * Class to hold code that generates JavaScript helper code.
 * Not unit-tested as just currently not worth it.
 *
 * @codeCoverageIgnore
 */
class GenerateFiles
{
    public function generateAllJavaScriptFiles(): void
    {
        $this->generateJavaScriptConstants();
        $this->generateJavaScriptTypes();
    }


    public function generateJavaScriptTypes(): void
    {
        $output_filename = __DIR__ . "/../../../app/public/tsx/generated/types.tsx";

        $content = "// This is an auto-generated file\n";
        $content .= "// DO NOT EDIT\n\n";
        $content .= "// You'll need to bounce the docker boxes to regenerate.\n";
        $content .= "//\n";
        $content .= "// or run 'php cli.php generate:javascript_constants' \n";

        $content .= "// Code for generating this file is in \Bristolian\CliController\GenerateFiles::generateJavaScriptTypes \n\n";

        $content .= "import { DateToString, convertDatesFromStrings } from '../functions';\n\n";

        $types = [
            \Bristolian\Model\BristolStairInfo::class,
            \Bristolian\Model\Chat\UserChatMessage::class,
            \Bristolian\Model\Chat\SystemChatMessage::class,

            \Bristolian\Model\IncomingEmail::class,
            \Bristolian\Model\ProcessorRunRecord::class,
            \Bristolian\Model\RoomLink::class,
            \Bristolian\Model\RoomSourceLink::class,
        ];

        $conversionFunctions = '';

        foreach ($types as $type) {
            [$interfaceContent, $dateFields] = generateInterfaceForClass($type);
            $content .= $interfaceContent;
            $content .= "\n";
            
            $conversionFunctions .= generateConversionFunctionForClass($type, $dateFields);
            $conversionFunctions .= "\n";
        }

        /**
         * @var $enums class-string[]
         */
        $enums = [
            \Bristolian\ChatMessage\ChatType::class,
            \Bristolian\Repo\ProcessorRepo\ProcessType::class,
        ];


        foreach ($enums as $enum) {
            $content .= generateEnumForClass($enum);
            $content .= "\n";
        }

        // Add conversion functions at the end
        $content .= $conversionFunctions;

        $result = file_put_contents($output_filename, $content);
        if ($result === false) {
            throw new BristolianException("Something went wrong writing to file in generateJavaScriptTypes");
        }
    }




    /**
     * This generates a TypeScript file that contains constants that need to be shared
     * between the front and backend e.g. the name for the field on a form that uploads
     * a file.
     */
    public function generateJavaScriptConstants(): void
    {
        $output_filename = __DIR__ . "/../../../app/public/tsx/generated/constants.tsx";

        $constants = [
            'MEME_FILE_UPLOAD_FORM_NAME' => \Bristolian\AppController\MemeUpload::MEME_FILE_UPLOAD_FORM_NAME,
            'ROOM_FILE_UPLOAD_FORM_NAME' => \Bristolian\AppController\Rooms::ROOM_FILE_UPLOAD_FORM_NAME,

            'BRISTOL_STAIRS_FILE_UPLOAD_FORM_NAME' => \Bristolian\AppController\BristolStairs::BRISTOL_STAIRS_FILE_UPLOAD_FORM_NAME,

            'SOURCELINK_JSON_MINIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkHighlightsJson::MINIMUM_LENGTH,
            'SOURCELINK_JSON_MAXIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkHighlightsJson::MAXIMUM_LENGTH,

            'SOURCELINK_TITLE_MINIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkTitle::MINIMUM_LENGTH,
            'SOURCELINK_TITLE_MAXIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkTitle::MAXIMUM_LENGTH,

            'SOURCELINK_TEXT_MAXIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkText::MAXIMUM_LENGTH,

            'SOURCE_LINK_MAX_PAGES' => \Bristolian\Parameters\PropertyType\SourceLinkPage::MAX_PAGES,

            'MINIMUM_DISPLAY_NAME_LENGTH' => \Bristolian\Parameters\PropertyType\DisplayName::MINIMUM_DISPLAY_NAME_LENGTH,
            'MAXIMUM_DISPLAY_NAME_LENGTH' => \Bristolian\Parameters\PropertyType\DisplayName::MAXIMUM_DISPLAY_NAME_LENGTH,

            'MINIMUM_ABOUT_ME_LENGTH' => \Bristolian\Parameters\PropertyType\AboutMeText::MINIMUM_ABOUT_ME_LENGTH,
            'MAXIMUM_ABOUT_ME_LENGTH' => \Bristolian\Parameters\PropertyType\AboutMeText::MAXIMUM_ABOUT_ME_LENGTH,
        ];

        $string_template = <<< TEMPLATE
export const :js_name: string = ":js_value";\n
TEMPLATE;

        $int_template = <<< TEMPLATE
export const :js_name: number = :js_value;\n
TEMPLATE;

        $content = "// This is an auto-generated file\n";
        $content .= "// DO NOT EDIT\n";
        $content .= "//\n";
        $content .= "// You'll need to bounce the docker boxes to regenerate.\n";
        $content .= "//\n";
        $content .= "// or run 'php cli.php generate:javascript_constants' \n";

        $content .= "// Code for generating this file is in \Bristolian\CliController\GenerateFiles::generateJavaScriptConstants \n";


        // TODO - add command name

        foreach ($constants as $constant_name => $constant_value) {
            $params = [
                ':js_name' => $constant_name,
                // Technically this is wrong. The escaping needed is
                // "string escape within JS". But JavaScript escaping is probably
                // safe.
                ':js_value' => $constant_value
            ];
            $template = $string_template;
            if (is_int($constant_value) === true) {
                $template = $int_template;
            }
            $content .= esprintf($template, $params);
        }

        $result = file_put_contents($output_filename, $content);
        if ($result === false) {
            throw new BristolianException("Something went wrong writing to file in generateJavaScriptConstants");
        }
    }

    /**
     * This generates a
     */
    public function generateTableHelperClasses(
        Config $config,
        PDO $pdo
    ) {
        $schema = $config->getDatabaseSchema();

        $table_query = "SELECT table_name FROM information_schema.tables
        WHERE table_schema = '$schema'";

        $statement = $pdo->query($table_query);

        if ($statement === false) {
            echo "Query failed.";
            exit(-1);
        }

        $rows = $statement->fetchAll();

        $column_query = <<< SQL
SELECT *
  FROM INFORMATION_SCHEMA.COLUMNS
  WHERE TABLE_SCHEMA = '$schema' AND TABLE_NAME = '%s';
SQL;

        foreach ($rows as $row) {
            $tableName = $row['TABLE_NAME'];
            $query = sprintf($column_query, $tableName);
            $columns_statement = $pdo->query($query);
            $columns_info = $columns_statement->fetchAll();

            generate_table_helper_class($tableName, $columns_info);
        }
    }
}
