<?php

namespace Bristolian\CliController;

use Bristolian\Config\Config;
use Bristolian\Exception\BristolianException;
use PDO;

function generate_table_strings($sorted_column_names)
{
    $separator = "";
    $columns_separated_by_comma_new_line = "";
    $values_names_separated_by_comma_new_line = "";

    foreach ($sorted_column_names as $column_name) {
//        if (strcasecmp($column_name, 'created_at') === 0) {
//            continue;
//        }
//        if (strcasecmp($column_name, 'updated_at') === 0) {
//            continue;
//        }

        $columns_separated_by_comma_new_line .= $separator . "    " . $column_name;
        $values_names_separated_by_comma_new_line .= $separator . "    :" . $column_name;
        $separator = ",\n";
    }

    $columns_separated_by_comma_new_line .= "\n";
    $values_names_separated_by_comma_new_line .= "\n";

    return [$columns_separated_by_comma_new_line, $values_names_separated_by_comma_new_line];
}


function generate_table_update_strings($sorted_column_names)
{
    $separator = "";
    $update_strings = "";

    foreach ($sorted_column_names as $column_name) {
        $update_strings .= $separator . "  $column_name = :" . $column_name ."";
        $separator = ",\n";
    }

    return $update_strings;
}







/**
 *
 * @codeCoverageIgnore
 * @param string $tableName
 * @param array $columns_info
 * @return void
 * @throws \Safe\Exceptions\FilesystemException
 */
function generate_table_helper_class(string $tableName, array $columns_info): void
{
    $output_filename = __DIR__ . "/../../Bristolian/Database/" . $tableName . ".php";

    $contents = "<?php\n\n";
    $contents .= "// Auto-generated file do not edit\n\n";
    $contents .= "// generated with 'php cli.php generate:php_table_helper_classes'\n\n";
    $contents .= "namespace Bristolian\\Database;\n\n";

    $columns_separated_by_comma_new_line = "";
    $values_names_separated_by_comma_new_line = "";


    $column_names_select = [];
    $column_names_insert = [];
    $column_names_update = [];
    foreach ($columns_info as $column) {
        $column_names_select[] = $column['COLUMN_NAME'];
        if (str_contains($column['EXTRA'], 'auto_increment') === true) {
            // auto-increment columns are autogenerated, not provided on insert.
            continue;
        }
        if (strcasecmp($column['COLUMN_NAME'], 'created_at') === 0) {
            continue;
        }
        if (strcasecmp($column['COLUMN_NAME'], 'updated_at') === 0) {
            continue;
        }

        $column_names_insert[] = $column['COLUMN_NAME'];

        if (str_ends_with($column['COLUMN_NAME'], 'id')) {
            continue;
        }

        $column_names_update[] = $column['COLUMN_NAME'];
    }

    // Insert
    $sorted_column_names_insert = customSort($column_names_insert);
    [$columns_separated_by_comma_new_line, $values_names_separated_by_comma_new_line]
        = generate_table_strings($sorted_column_names_insert);

    $contents .= "class $tableName\n";
    $contents .= "{\n";
    $contents .= "    const INSERT = <<< SQL\n";
    $contents .= "insert into $tableName (\n";
    $contents .= $columns_separated_by_comma_new_line;
    $contents .= ")\n";
    $contents .= "values (\n";
    $contents .= $values_names_separated_by_comma_new_line;
    $contents .= ")\n";
    $contents .= "SQL;\n\n";

    // Select
    $sorted_column_names_select = customSort($column_names_select);
    [$columns_separated_by_comma_new_line, $values_names_separated_by_comma_new_line]
        = generate_table_strings($sorted_column_names_select);

    $contents .= "    const SELECT = <<< SQL\n";
    $contents .= "select\n";
    $contents .= $columns_separated_by_comma_new_line;
    $contents .= "from\n  $tableName \n"; // trailing space to avoid errors
    $contents .= "SQL;\n\n";

    // Update
    $sorted_column_names_update = customSort($column_names_update);
    $update_string = generate_table_update_strings($sorted_column_names_update);
    $contents .= "    const UPDATE = <<< SQL\n";
    $contents .= "update\n";
    $contents .= "  $tableName\n";
    $contents .= "set\n";
    $contents .= $update_string . "\n";
    $contents .= "where\n";
    $contents .= "  id = :id\n";
    $contents .= "  limit 1\n"; // useless?
    $contents .= "SQL;\n\n";
    $contents .= "}\n";



    \Safe\file_put_contents($output_filename, $contents);
}


/**
 * Function to generate TypeScript definition of an interface for a PHP
 * class, so that data transferred from PHP to the front-end can be typed.
 *
 * Code is not unit tested as just not worth it currently.
 *
 * @codeCoverageIgnore
 * @param class-string $type
 * @return string
 */
function generateInterfaceForClass(string $type): string
{

    // TODO - this is a hack. It would almost certainly be better to
    // use https://www.npmjs.com/package/openapi-typescript but as our
    // Open API spec isn't generating, this will work for the time being.

    $content = '';

    $rc = new \ReflectionClass($type);

    $name = $rc->getShortName();
    $content .= "// $type\n";
    $content .= "export interface $name {\n";

    foreach ($rc->getProperties() as $property) {
        $nullable = false;

        $php_type = $property->getType();
        $php_type = (string)$php_type;

//        var_dump($php_type);

        if (str_starts_with($php_type, "?") === true) {
            $php_type = ltrim($php_type, '?');
            $nullable = true;
        }


        if (strcasecmp($php_type, 'DateTimeImmutable') === 0 ||
            strcasecmp($php_type, 'DateTimeInterface') === 0 ||
            strcasecmp($php_type, 'DateTime') === 0) {
            $php_type = "DateTime";
        }

        if (strcasecmp($php_type, 'int') === 0) {
            $php_type = "number";
        }

//        if (str_starts_with($php_type, '?') === true) {
//            $php_type = substr($php_type, 1) . "|null";
//        }
//
        if ($nullable === true) {
            $php_type .= "|null";
        }

        $content .= "    " . $property->getName() . ": " . $php_type . ";\n";
    }

    $content .= "}\n";

    return $content;
}

/**
 * Function to generate TypeScript definition of an enum from a PHP
 * Backed Enum class, so that data transferred from PHP to the front-end can be typed.
 *
 * Code is not unit tested as just not worth it currently.
 *
 * @codeCoverageIgnore
 * @param class-string $type
 * @return string
 */
function generateEnumForClass(string $type): string
{
    $content = '';

    $rc = new \ReflectionClass($type);

    $cases = getEnumCases($type);

    $name = $rc->getShortName();
    $content .= "// $type\n";
    $content .= "export enum $name {\n";


    // Iterate over all cases and print name and value
    foreach ($cases as $case) {
        if (is_string($case->value) === true) {
            $content .= sprintf(
                "  %s = \"%s\",\n",
                $case->name,
                $case->value
            );
        }
        else if (is_int($case->value) === true) {
            $content .= sprintf(
                "  %s = %s,\n",
                $case->name,
                $case->value
            );
        }
        else {
            throw new \Exception("Unsupported type (neither string nor int) '" . var_export($case, true) . "'.");
        }
    }


    $content .= "}\n";





    return $content;
}









/**
 * Class to hold code that generates JavaScript helper code.
 * Not unit-tested as just currently not worth it.
 *
 * @codeCoverageIgnore
 */
class GenerateFiles
{
    public function generateAllJavaScriptFiles(): void
    {
        $this->generateJavaScriptConstants();
        $this->generateJavaScriptTypes();
    }


    public function generateJavaScriptTypes(): void
    {
        $output_filename = __DIR__ . "/../../../app/public/tsx/generated/types.tsx";

        $content = "// This is an auto-generated file\n";
        $content .= "// DO NOT EDIT\n\n";
        $content .= "// You'll need to bounce the docker boxes to regenerate.\n\n";

        $content .= 'import { DateTime } from "luxon";' . "\n\n";

        $types = [
            \Bristolian\Model\IncomingEmail::class,
            \Bristolian\Model\RoomLink::class,
            \Bristolian\Model\RoomSourceLink::class,
            \Bristolian\Model\ProcessorRunRecord::class,
        ];



        foreach ($types as $type) {
            $content .= generateInterfaceForClass($type);
            $content .= "\n";
        }

        /**
         * @var $enums class-string[]
         */
        $enums = [
            \Bristolian\Repo\ProcessorRepo\ProcessType::class
        ];


        foreach ($enums as $enum) {
            $content .= generateEnumForClass($enum);
            $content .= "\n";
        }

        $result = file_put_contents($output_filename, $content);
        if ($result === false) {
            throw new BristolianException("Something went wrong writing to file in generateJavaScriptTypes");
        }
    }




    /**
     * This generates a TypeScript file that contains constants that need to be shared
     * between the front and backend e.g. the name for the field on a form that uploads
     * a file.
     */
    public function generateJavaScriptConstants(): void
    {
        $output_filename = __DIR__ . "/../../../app/public/tsx/generated/constants.tsx";

        $constants = [
            'MEME_FILE_UPLOAD_FORM_NAME' => \Bristolian\AppController\MemeUpload::MEME_FILE_UPLOAD_FORM_NAME,
            'ROOM_FILE_UPLOAD_FORM_NAME' => \Bristolian\AppController\Rooms::ROOM_FILE_UPLOAD_FORM_NAME,

            'SOURCELINK_JSON_MINIMUM_LENGTH' => \Bristolian\Parameters\SourceLinkHighlightsJson::MINIMUM_LENGTH,
            'SOURCELINK_JSON_MAXIMUM_LENGTH' => \Bristolian\Parameters\SourceLinkHighlightsJson::MAXIMUM_LENGTH,

            'SOURCELINK_TITLE_MINIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkTitle::MINIMUM_LENGTH,
            'SOURCELINK_TITLE_MAXIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkTitle::MAXIMUM_LENGTH,

            'SOURCELINK_TEXT_MAXIMUM_LENGTH' => \Bristolian\Parameters\PropertyType\SourceLinkText::MAXIMUM_LENGTH,

            'SOURCE_LINK_MAX_PAGES' => \Bristolian\Parameters\PropertyType\SourceLinkPage::MAX_PAGES,
        ];

        $string_template = <<< TEMPLATE
export const :js_name: string = ":js_value";\n
TEMPLATE;

        $int_template = <<< TEMPLATE
export const :js_name: number = :js_value;\n
TEMPLATE;

        $content = "// This is an auto-generated file\n";
        $content .= "// DO NOT EDIT\n\n";
        $content .= "// You'll need to bounce the docker boxes to regenerate.\n\n";
        // TODO - add command name

        foreach ($constants as $constant_name => $constant_value) {
            $params = [
                ':js_name' => $constant_name,
                // Technically this is wrong. The escaping needed is
                // "string escape within JS". But JavaScript escaping is probably
                // safe.
                ':js_value' => $constant_value
            ];
            $template = $string_template;
            if (is_int($constant_value) === true) {
                $template = $int_template;
            }
            $content .= esprintf($template, $params);
        }

        $result = file_put_contents($output_filename, $content);
        if ($result === false) {
            throw new BristolianException("Something went wrong writing to file in generateJavaScriptConstants");
        }
    }

    /**
     * This generates a
     */
    public function generateTableHelperClasses(
        Config $config,
        PDO $pdo
    ) {
        $schema = $config->getDatabaseSchema();

        $table_query = "SELECT table_name FROM information_schema.tables
        WHERE table_schema = '$schema'";

        $statement = $pdo->query($table_query);

        if ($statement === false) {
            echo "Query failed.";
            exit(-1);
        }

        $rows = $statement->fetchAll();

        $column_query = <<< SQL
SELECT *
  FROM INFORMATION_SCHEMA.COLUMNS
  WHERE TABLE_SCHEMA = '$schema' AND TABLE_NAME = '%s';
SQL;

        foreach ($rows as $row) {
            $tableName = $row['TABLE_NAME'];
            $query = sprintf($column_query, $tableName);
            $columns_statement = $pdo->query($query);
            $columns_info = $columns_statement->fetchAll();

            generate_table_helper_class($tableName, $columns_info);
        }
    }
}
